1) shared/schema.ts (normalize Intervention Summaries)
// shared/schema.ts
export interface PatientProfile {
  id: string;
  email: string;
  first_name?: string;
  last_name?: string;
  role?: 'patient' | 'therapist' | string;
}

export interface AnxietyAnalysis {
  id: string;
  user_id: string;
  created_at: string;
  anxiety_level: number;
  anxiety_triggers?: string[] | string;
  coping_strategies?: string[] | string;
  personalized_response?: string;
  patient_message?: string;
}

export interface GoalProgressEntry {
  date: string;
  score?: number;
  note?: string;
}

export interface Goal {
  id: string;
  user_id: string;
  title: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  start_date: string;
  created_at?: string;
  updated_at?: string;
  goal_progress?: GoalProgressEntry[];
}

export interface InterventionSummary {
  id: string;                 // normalized id
  user_id: string;
  week_start: string;         // ISO
  week_end: string;           // ISO
  intervention_type: string;  // snake_case
  conversation_count: number;
  key_points: string[];
  recommendations: string[];
  limitations: string[];
  created_at?: string;
}

// Helper: coerce an arbitrary object into a normalized InterventionSummary
export const normalizeInterventionSummary = (s: any): InterventionSummary => {
  const toArray = (v: unknown): string[] => {
    if (Array.isArray(v)) return v.filter(Boolean).map(String);
    if (typeof v === 'string' && v.trim().length) {
      // handle "{...}" or 'a, b, c'
      if (v.startsWith('{') && v.endsWith('}')) {
        return v
          .slice(1, -1)
          .split('","')
          .map(t => t.replace(/^"|"$/g, '').trim())
          .filter(Boolean);
      }
      return v.split(',').map(t => t.trim()).filter(Boolean);
    }
    return [];
  };

  const id = String(
    s.id ??
      `${s.user_id ?? s.userId ?? 'u'}-${s.week_start ?? s.weekStart ?? Date.now()}`
  );

  const week_start =
    s.week_start ??
    s.weekStart ??
    s.week ?? // some backends use week
    new Date().toISOString();

  const week_end =
    s.week_end ??
    s.weekEnd ??
    week_start;

  const intervention_type = String(
    s.intervention_type ?? s.interventionType ?? s.type ?? 'unknown'
  )
    .replace(/[\s-]+/g, '_')
    .toLowerCase();

  const conversation_count = Number(s.conversation_count ?? s.conversationCount ?? 0);

  return {
    id,
    user_id: String(s.user_id ?? s.userId ?? 'unknown'),
    week_start,
    week_end,
    intervention_type,
    conversation_count,
    key_points: toArray(s.key_points ?? s.keyPoints),
    recommendations: toArray(s.recommendations),
    limitations: toArray(s.limitations ?? s.limitation_points),
    created_at: s.created_at ?? s.createdAt,
  };
};

2) server/storage.ts (ensure correct, patient-scoped reads)
// server/storage.ts
// Replace your implementations with these safe, patient-scoped versions.
// These are examples — wire to your DB client (Supabase/Prisma/SQL) as appropriate.

import { normalizeInterventionSummary } from '../shared/schema';

export const storage = {
  async getProfile(userId: string) {
    // SELECT * FROM profiles WHERE id = $1 LIMIT 1
    const row = await db.profiles.findOne({ id: userId });
    if (!row) return null;
    return {
      id: row.id,
      email: row.email,
      first_name: row.first_name,
      last_name: row.last_name,
      role: row.role
    };
  },

  async getAnxietyAnalysesByUser(userId: string) {
    // SELECT * FROM anxiety_analyses WHERE user_id = $1 ORDER BY created_at DESC
    const rows = await db.anxiety_analyses.findMany({ user_id: userId }, { orderBy: { created_at: 'desc' }});
    return rows ?? [];
  },

  async getChatMessagesByUser(userId: string) {
    // SELECT * FROM chat_messages WHERE user_id = $1 ORDER BY created_at DESC
    const rows = await db.chat_messages.findMany({ user_id: userId }, { orderBy: { created_at: 'desc' }});
    return rows ?? [];
  },

  async getUserGoalsByUser(userId: string) {
    // SELECT * FROM goals WHERE user_id = $1 ORDER BY created_at DESC
    const rows = await db.goals.findMany({ user_id: userId }, { orderBy: { created_at: 'desc' }});
    return rows ?? [];
  },

  async getInterventionSummariesByUser(userId: string) {
    // Your data might be in any of these tables/columns — unify here:
    // SELECT * FROM intervention_summaries WHERE user_id = $1
    const raw =
      (await db.intervention_summaries.findMany({ user_id: userId })) ??
      [];

    // Some deployments stored as `interventions` or `weekly_interventions`
    const alt =
      (await db.interventions?.findMany?.({ user_id: userId })) ??
      (await db.weekly_interventions?.findMany?.({ user_id: userId })) ??
      [];

    const merged = [...raw, ...alt];
    return merged.map(normalizeInterventionSummary);
  },
};


Replace db.* calls with your real persistence layer. The key is return arrays scoped to user_id only and normalize summaries.

3) server/routes.ts (correct therapist analytics route)
// server/routes.ts
import express from 'express';
import { storage } from './storage';
import { normalizeInterventionSummary } from '../shared/schema';

const app = express();

// ✅ Fixed: strictly patient-scoped, normalized payload, robust keys
app.get('/api/therapist/patient-analytics', async (req, res) => {
  try {
    const { patientId, therapistEmail } = req.query;

    if (!patientId || !therapistEmail) {
      return res.status(400).json({ error: 'patientId and therapistEmail required' });
    }

    // (Optional) authorize therapist -> patient access here.

    const [profile, analyses, messages, goals, summariesRaw] = await Promise.all([
      storage.getProfile(String(patientId)),
      storage.getAnxietyAnalysesByUser(String(patientId)),
      storage.getChatMessagesByUser(String(patientId)),
      storage.getUserGoalsByUser(String(patientId)),
      storage.getInterventionSummariesByUser(String(patientId))
    ]);

    // Normalize summaries in case storage returns mixed shapes
    const summaries = (summariesRaw ?? []).map(normalizeInterventionSummary);

    return res.json({
      profile,
      analyses,
      messages,
      goals,
      summaries, // ✅ unified key
    });
  } catch (error) {
    console.error('Therapist analytics error:', error);
    return res.status(500).json({ error: 'Failed to load patient analytics' });
  }
});

// (Optional) A safe, POSTable patient-search route you’re already using
app.get('/api/therapist/search-patient', async (req, res) => {
  // ... your existing logic
});

export default app;

4) client/src/components/analytics/InterventionSummariesSection.tsx (robust renderer)
// client/src/components/analytics/InterventionSummariesSection.tsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { MessageSquare } from 'lucide-react';

type Summary = {
  id: string;
  week_start: string;
  week_end: string;
  intervention_type: string;
  conversation_count: number;
  key_points: string[];
  recommendations: string[];
  limitations: string[];
  created_at?: string;
};

interface Props {
  summaries: Summary[] | null | undefined;
  analyses?: any[];
  messages?: any[];
  goals?: any[];
}

const InterventionSummariesSection: React.FC<Props> = ({ summaries }) => {
  const items = Array.isArray(summaries) ? summaries : [];

  return (
    <Card>
      <CardHeader className="flex items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <MessageSquare className="w-5 h-5 text-blue-600" />
          Weekly Intervention Summaries
        </CardTitle>
        <Badge variant="secondary">{items.length} week{items.length === 1 ? '' : 's'}</Badge>
      </CardHeader>
      <CardContent>
        {items.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            No intervention summaries available yet.
          </div>
        ) : (
          <div className="space-y-4">
            {items.map((s) => (
              <div key={s.id} className="p-4 border rounded-lg bg-white">
                <div className="flex flex-wrap items-center justify-between gap-2 mb-2">
                  <div className="font-semibold">
                    {new Date(s.week_start).toLocaleDateString()} — {new Date(s.week_end).toLocaleDateString()}
                  </div>
                  <div className="flex items-center gap-2">
                    <Badge className="capitalize">{s.intervention_type.replace(/_/g, ' ')}</Badge>
                    <Badge variant="outline">{s.conversation_count} conv.</Badge>
                  </div>
                </div>

                {s.key_points?.length > 0 && (
                  <div className="mt-2">
                    <div className="text-sm font-medium text-gray-700">Key points</div>
                    <ul className="list-disc ml-6 text-sm text-gray-700">
                      {s.key_points.map((kp, i) => (
                        <li key={i}>{kp}</li>
                      ))}
                    </ul>
                  </div>
                )}

                {s.recommendations?.length > 0 && (
                  <div className="mt-3">
                    <div className="text-sm font-medium text-gray-700">Recommendations</div>
                    <ul className="list-disc ml-6 text-sm text-gray-700">
                      {s.recommendations.map((r, i) => (
                        <li key={i}>{r}</li>
                      ))}
                    </ul>
                  </div>
                )}

                {s.limitations?.length > 0 && (
                  <div className="mt-3">
                    <div className="text-sm font-medium text-gray-700">Limitations</div>
                    <ul className="list-disc ml-6 text-sm text-gray-700">
                      {s.limitations.map((l, i) => (
                        <li key={i}>{l}</li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default InterventionSummariesSection;

5) client/src/pages/TherapistPortal.tsx (pass normalized summaries, always render)

Replace your file with the version below (already aligned with your latest message, but with tiny fixes: consistent snake/camel handling, summaries normalization, and no z-index overlays).

// client/src/pages/TherapistPortal.tsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '@/hooks/useAuth';

import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { User, Search, TrendingUp, Target, MessageSquare } from 'lucide-react';
import AnalyticsHeader from '@/components/analytics/AnalyticsHeader';
import AnalyticsMetrics from '@/components/analytics/AnalyticsMetrics';
import AnxietyChartsSection from '@/components/analytics/AnxietyChartsSection';
import MonthlyChartsSection from '@/components/analytics/MonthlyChartsSection';
import GoalProgressSection from '@/components/analytics/GoalProgressSection';
import TriggerAnalysisTable from '@/components/analytics/TriggerAnalysisTable';
import TreatmentOutcomes from '@/components/TreatmentOutcomes';
import InterventionSummariesSection from '@/components/analytics/InterventionSummariesSection';
import { processTriggerData, processSeverityDistribution } from '@/utils/analyticsDataProcessor';

interface PatientConnection {
  id: string;
  user_id: string;
  therapist_name: string;
  contact_value: string;
  notes?: string;
  created_at: string;
  patient_profile?: {
    first_name?: string;
    last_name?: string;
    email?: string;
  };
}

const TherapistPortal: React.FC = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const [therapistEmail, setTherapistEmail] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [patients, setPatients] = useState<PatientConnection[]>([]);
  const [selectedPatientId, setSelectedPatientId] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [searchEmail, setSearchEmail] = useState('');
  const [searchCode, setSearchCode] = useState('');
  const [searchLoading, setSearchLoading] = useState(false);

  const handleTherapistLogin = async () => {
    if (!therapistEmail.trim()) {
      toast({ title: 'Email Required', description: 'Please enter your email address', variant: 'destructive' });
      return;
    }
    setLoading(true);
    try {
      setIsAuthenticated(true);
      toast({ title: 'Access Granted', description: 'Welcome to the therapist portal' });
    } finally {
      setLoading(false);
    }
  };

  const searchPatients = async () => {
    if (!searchEmail.trim() && !searchCode.trim()) {
      toast({ title: 'Search Required', description: "Please enter a patient's email or 6-digit code", variant: 'destructive' });
      return;
    }

    setSearchLoading(true);
    try {
      const searchParams = new URLSearchParams();
      if (searchEmail.trim()) searchParams.append('email', searchEmail.toLowerCase());
      else if (searchCode.trim()) searchParams.append('code', searchCode.trim());

      const response = await fetch(`/api/therapist/search-patient?${searchParams}`);
      if (!response.ok) throw new Error('Failed to search patients');
      const profiles = await response.json();

      const patientProfiles = (profiles ?? []).filter((p: any) => p.role === 'patient');
      if (patientProfiles.length === 0) {
        toast({ title: 'No Patients Found', description: 'No patients found with the provided search criteria', variant: 'destructive' });
        setPatients([]);
        return;
      }

      const formatted = patientProfiles.map((profile: any) => ({
        id: profile.id,
        user_id: profile.id,
        therapist_name: therapistEmail,
        contact_value: therapistEmail,
        created_at: new Date().toISOString(),
        patient_profile: {
          first_name: profile.first_name,
          last_name: profile.last_name,
          email: profile.email
        }
      }));

      setPatients(formatted);
      toast({ title: 'Search Complete', description: `Found ${patientProfiles.length} patient(s)` });
    } catch (err) {
      toast({ title: 'Error', description: 'Failed to search for patients', variant: 'destructive' });
    } finally {
      setSearchLoading(false);
    }
  };

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
        <Card className="max-w-md w-full p-8">
          <div className="text-center mb-8">
            <div className="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <User className="w-8 h-8 text-blue-600" />
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Therapist Portal</h1>
            <p className="text-gray-600">Enter your email to access your patients' progress data</p>
          </div>

          <div className="space-y-4">
            <div>
              <Label htmlFor="therapist-email">Email Address</Label>
              <Input
                id="therapist-email"
                type="email"
                value={therapistEmail}
                onChange={(e) => setTherapistEmail(e.target.value)}
                placeholder="dr.smith@example.com"
                onKeyDown={(e) => e.key === 'Enter' && handleTherapistLogin()}
              />
            </div>
            <Button onClick={handleTherapistLogin} className="w-full" disabled={loading}>
              {loading ? 'Verifying...' : 'Access Portal'}
            </Button>
          </div>

          <div className="mt-6 p-4 bg-blue-50 rounded-lg">
            <p className="text-sm text-blue-800">
              <strong>Demo Note:</strong> Enter any email address that patients have used to connect with you.
              This portal shows the same analytics and outcomes that patients see in their app.
            </p>
          </div>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="bg-white border-b border-gray-200 px-6 py-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Therapist Portal</h1>
            <p className="text-gray-600">Logged in as: {therapistEmail}</p>
          </div>
          <Button
            variant="outline"
            onClick={() => {
              setIsAuthenticated(false);
              setSelectedPatientId(null);
              setTherapistEmail('');
            }}>
            Sign Out
          </Button>
        </div>
      </div>

      <div className="flex">
        {/* Sidebar */}
        <div className="w-80 bg-white border-r border-gray-200 h-screen overflow-y-auto">
          <div className="p-6">
            <div className="flex items-center space-x-2 mb-4">
              <Search className="w-5 h-5 text-gray-500" />
              <h2 className="text-lg font-semibold text-gray-900">Search Patients</h2>
            </div>

            <div className="space-y-3 mb-6">
              <div>
                <Label htmlFor="search-email">Patient Email</Label>
                <Input
                  id="search-email"
                  type="email"
                  value={searchEmail}
                  onChange={(e) => setSearchEmail(e.target.value)}
                  placeholder="patient@example.com"
                />
              </div>
              <div>
                <Label htmlFor="search-code">Patient Code</Label>
                <Input
                  id="search-code"
                  type="text"
                  value={searchCode}
                  onChange={(e) => setSearchCode(e.target.value)}
                  placeholder="6-digit code from email"
                  maxLength={6}
                />
              </div>
              <Button onClick={searchPatients} className="w-full" disabled={searchLoading}>
                {searchLoading ? 'Searching...' : 'Search Patients'}
              </Button>
            </div>

            <div className="flex items-center space-x-2 mb-4">
              <User className="w-5 h-5 text-gray-500" />
              <h3 className="text-lg font-semibold text-gray-900">Results ({patients.length})</h3>
            </div>

            <div className="space-y-3">
              {(patients ?? []).map((patient) => {
                const patientName = (patient.patient_profile?.first_name || patient.patient_profile?.last_name)
                  ? `${patient.patient_profile?.first_name || ''} ${patient.patient_profile?.last_name || ''}`.trim()
                  : patient.patient_profile?.email || 'Patient (No Name Available)';

                const isSelected = selectedPatientId === patient.user_id;

                return (
                  <Card
                    key={patient.id}
                    className={`p-4 cursor-pointer transition-colors ${
                      isSelected ? 'bg-blue-50 border-blue-200' : 'hover:bg-gray-50'
                    }`}
                    onClick={() => setSelectedPatientId(patient.user_id)}
                  >
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="font-medium text-gray-900">{patientName}</h3>
                        <p className="text-sm text-gray-500">Connected {new Date(patient.created_at).toLocaleDateString()}</p>
                        <p className="text-xs text-gray-400">ID: {patient.user_id}</p>
                      </div>
                      {isSelected && <Badge variant="secondary">Active</Badge>}
                    </div>
                  </Card>
                );
              })}
            </div>
          </div>
        </div>

        {/* Main content */}
        <div className="flex-1 p-6">
          {selectedPatientId ? (
            <PatientAnalytics patientId={selectedPatientId} />
          ) : (
            <div className="text-center py-12">
              <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <Search className="w-8 h-8 text-gray-400" />
              </div>
              <h3 className="text-lg font-medium text-gray-900 mb-2">Select a Patient</h3>
              <p className="text-gray-500">Choose a patient from the sidebar to view their analytics and progress</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// Helper
const calculateGoalCompletionRate = (goal: any): number => {
  if (!goal.goal_progress || goal.goal_progress.length === 0) return 0;
  const today = new Date();
  const startDate = new Date(goal.start_date);
  const daysSinceStart = Math.ceil((today.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  const expected =
    goal.frequency === 'daily' ? Math.max(1, daysSinceStart)
      : goal.frequency === 'weekly' ? Math.max(1, Math.ceil(daysSinceStart / 7))
      : goal.frequency === 'monthly' ? Math.max(1, Math.ceil(daysSinceStart / 30))
      : 1;
  const actual = goal.goal_progress.length;
  return Math.min(100, (actual / expected) * 100);
};

const PatientAnalytics: React.FC<{ patientId: string }> = ({ patientId }) => {
  const [patientProfile, setPatientProfile] = useState<any>(null);
  const [analyses, setAnalyses] = useState<any[]>([]);
  const [messages, setMessages] = useState<any[]>([]);
  const [goals, setGoals] = useState<any[]>([]);
  const [summaries, setSummaries] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();
  const { user } = useAuth();
  const therapistEmail = user?.email;

  useEffect(() => {
    const fetchPatientData = async () => {
      try {
        setLoading(true);
        setPatientProfile(null);
        setAnalyses([]);
        setMessages([]);
        setGoals([]);
        setSummaries([]);

        const url = `/api/therapist/patient-analytics?patientId=${encodeURIComponent(patientId)}&therapistEmail=${encodeURIComponent(therapistEmail || '')}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Therapist analytics fetch failed: ${res.status}`);
        const payload = await res.json();

        // Normalize analyses minimally
        const toArray = (v: unknown) =>
          Array.isArray(v) ? v :
          typeof v === 'string' && v.startsWith('{') && v.endsWith('}')
            ? v.slice(1, -1).split('","').map(s => s.replace(/^"|"$/g, '').trim()).filter(Boolean)
            : typeof v === 'string'
              ? v.split(',').map(s => s.trim()).filter(Boolean)
              : [];

        const processedAnalyses = (payload.analyses ?? []).map((a: any) => ({
          id: a.id ?? `${a.user_id}-${a.created_at}`,
          user_id: a.user_id ?? a.userId,
          anxietyLevel: a.anxiety_level ?? a.anxietyLevel ?? 0,
          triggers: toArray(a.anxiety_triggers ?? a.anxietyTriggers),
          copingStrategies: toArray(a.coping_strategies ?? a.copingStrategies),
          patient_message: a.patient_message,
          created_at: a.created_at ?? a.createdAt,
          gad7Score: Math.round(((a.anxiety_level ?? a.anxietyLevel ?? 0) * 2.1))
        }));

        const processedGoals = (payload.goals ?? []).map((g: any) => {
          const progressEntries = g.goal_progress || [];
          const avgScore = progressEntries.length
            ? progressEntries.reduce((sum: number, p: any) => sum + (p.score ?? 0), 0) / progressEntries.length
            : 0;
          return {
            ...g,
            progress_history: progressEntries,
            average_score: avgScore,
            completion_rate: calculateGoalCompletionRate(g),
            latest_progress: progressEntries[0] || null,
          };
        });

        const rawSummaries = payload.summaries ?? payload.interventions ?? payload.interventionSummaries ?? [];
        setPatientProfile(payload.profile ?? null);
        setAnalyses(processedAnalyses);
        setMessages(payload.messages ?? []);
        setGoals(processedGoals);
        setSummaries(rawSummaries); // already normalized by server

      } catch (error: any) {
        console.error(error);
        toast({ title: 'Error', description: 'Failed to load patient data', variant: 'destructive' });
      } finally {
        setLoading(false);
      }
    };
    fetchPatientData();
  }, [patientId]);

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" />
          <p className="text-gray-500">Loading patient data...</p>
        </div>
      </div>
    );
  }

  const hasAnalysesData = analyses.length > 0;
  const totalEntries = hasAnalysesData ? analyses.length : 0;
  const avgAnxiety = hasAnalysesData
    ? analyses.reduce((sum, a) => sum + (a.anxietyLevel ?? 0), 0) / analyses.length
    : 0;

  const allTriggers = hasAnalysesData ? analyses.flatMap(a => a.triggers || []) : [];
  const triggerCounts = allTriggers.reduce((acc: Record<string, number>, t: string) => {
    acc[t] = (acc[t] || 0) + 1;
    return acc;
  }, {});
  const mostCommonTrigger = Object.entries(triggerCounts).sort(([, A], [, B]) => (B as number) - (A as number))[0] ?? ['N/A', 0];

  const isolatedPatientAnalyses = analyses;
  const isolatedPatientGoals = goals;

  const triggerData = processTriggerData(isolatedPatientAnalyses);
  const severityDistribution = processSeverityDistribution(isolatedPatientAnalyses);

  const patientName =
    (patientProfile?.first_name || patientProfile?.last_name)
      ? `${patientProfile?.first_name || ''} ${patientProfile?.last_name || ''}`.trim()
      : 'Patient';

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <TrendingUp className="w-6 h-6 text-blue-600" />
          <div>
            <h2 className="text-2xl font-bold text-gray-900">{patientName} - Analytics</h2>
            <p className="text-gray-600">{patientProfile?.email}</p>
          </div>
        </div>
        <Badge variant="secondary">Patient ID: {patientId.substring(0, 8)}</Badge>
      </div>

      <AnalyticsHeader
        analysesCount={analyses.length}
        onDownloadHistory={() => {/* keep your handler */}}
        onShareWithTherapist={() => {}}
        onDownloadSummary={() => {/* keep your handler */}}
      />

      {hasAnalysesData ? (
        <>
          <AnalyticsMetrics
            totalEntries={totalEntries}
            averageAnxiety={avgAnxiety}
            mostCommonTrigger={{ trigger: String(mostCommonTrigger[0]), count: Number(mostCommonTrigger[1]) }}
          />

          <AnxietyChartsSection
            triggerData={triggerData}
            severityDistribution={severityDistribution}
            analyses={isolatedPatientAnalyses}
          />

          <MonthlyChartsSection analyses={isolatedPatientAnalyses} />
          <TreatmentOutcomes analyses={isolatedPatientAnalyses} />
          <TriggerAnalysisTable triggerData={triggerData} totalEntries={totalEntries} />
        </>
      ) : (
        <div className="text-center py-12">
          <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <TrendingUp className="w-8 h-8 text-gray-400" />
          </div>
          <h3 className="text-lg font-medium text-gray-900 mb-2">No Anxiety Data Yet</h3>
          <p className="text-gray-500">This patient hasn’t started tracking anxiety yet.</p>
        </div>
      )}

      {/* ✅ Always render summaries (defensive component handles empty case) */}
      <InterventionSummariesSection
        summaries={summaries}
        analyses={isolatedPatientAnalyses}
        messages={messages}
        goals={goals}
      />

      {/* Goals */}
      <div className="space-y-6">
        <div className="flex items-center space-x-2 mb-4">
          <Target className="w-5 h-5 text-purple-600" />
          <h3 className="text-xl font-semibold text-gray-900">Goal Progress Overview</h3>
        </div>
        {goals.length > 0 ? (
          <GoalProgressSection goals={isolatedPatientGoals} />
        ) : (
          <div className="text-center py-8">
            <div className="w-12 h-12 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-3">
              <Target className="w-6 h-6 text-purple-600" />
            </div>
            <p className="text-gray-500">No goals set yet</p>
          </div>
        )}
      </div>

      <div className="mt-8 p-4 bg-blue-50 rounded-lg">
        <p className="text-sm text-blue-800">
          <strong>Therapist Note:</strong> This view mirrors the patient app. Data updates in real time.
        </p>
      </div>
    </div>
  );
};

export default TherapistPortal;

6) TTS — consistent voices + faster first utterance
6a) hooks/speech/useVoiceSelection.ts (new, shared voice chooser)
// client/src/hooks/speech/useVoiceSelection.ts
import { useMemo } from 'react';

export type Lang = 'en' | 'es';

const EN_PREFERENCES = [
  // Try high-quality natural female voices first (varies by OS/Browser)
  'Microsoft Aria Online (Natural) - English (United States)',
  'Microsoft Jenny Online (Natural) - English (United States)',
  'Google UK English Female',
  'Google US English',
  'Samantha',          // macOS
  'Victoria',          // macOS
];

const ES_PREFERENCES = [
  'Microsoft Paloma Online (Natural) - Spanish (Mexico)',
  'Microsoft Dalia Online (Natural) - Spanish (Mexico)',
  'Google español de Estados Unidos',
  'Google español',
  'Paulina',           // macOS
  'Monica',            // macOS
];

const pickFirstAvailable = (names: string[], voices: SpeechSynthesisVoice[]) => {
  for (const name of names) {
    const v = voices.find((x) => x.name === name);
    if (v) return v;
  }
  return null;
};

export const useVoiceSelection = () => {
  const findBestVoiceForLanguage = useMemo(
    () => (lang: Lang): SpeechSynthesisVoice | null => {
      if (typeof window === 'undefined' || !window.speechSynthesis) return null;
      let voices = window.speechSynthesis.getVoices();
      if (!voices || voices.length === 0) {
        // best-effort: poke to load voices
        const u = new SpeechSynthesisUtterance('');
        window.speechSynthesis.speak(u);
        window.speechSynthesis.cancel();
        voices = window.speechSynthesis.getVoices();
      }

      if (lang === 'es') {
        return (
          pickFirstAvailable(ES_PREFERENCES, voices) ||
          voices.find(v => v.lang?.toLowerCase().startsWith('es-')) ||
          null
        );
      }
      return (
        pickFirstAvailable(EN_PREFERENCES, voices) ||
        voices.find(v => v.lang?.toLowerCase().startsWith('en-')) ||
        null
      );
    },
    []
  );

  return { findBestVoiceForLanguage };
};

6b) hooks/useSpeechSynthesis.tsx (use shared selector + faster start)
// client/src/hooks/useSpeechSynthesis.tsx
import { useEffect, useCallback } from 'react';
import { useVoiceSelection, Lang } from './speech/useVoiceSelection';
import { useSpeechState } from './speech/useSpeechState';

export const useSpeechSynthesis = () => {
  const {
    isSpeaking,
    setIsSpeaking,
    speechSynthesisSupported,
    setSpeechSynthesisSupported,
    currentUtteranceRef,
    speechTimeoutRef,
    isProcessingRef,
    lastRequestIdRef
  } = useSpeechState();

  const { findBestVoiceForLanguage } = useVoiceSelection();

  useEffect(() => {
    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
      setSpeechSynthesisSupported(true);

      const preload = () => {
        const v = window.speechSynthesis.getVoices();
        return v.length;
      };
      if ('onvoiceschanged' in window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = preload;
      }
      preload();
      window.speechSynthesis.cancel();
    } else {
      setSpeechSynthesisSupported(false);
    }
  }, [setSpeechSynthesisSupported]);

  const cancelSpeech = useCallback(() => {
    if (speechTimeoutRef.current) {
      clearTimeout(speechTimeoutRef.current);
      speechTimeoutRef.current = null;
    }
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
    }
    isProcessingRef.current = false;
    currentUtteranceRef.current = null;
    lastRequestIdRef.current = null;
    setIsSpeaking(false);
  }, [speechTimeoutRef, isProcessingRef, currentUtteranceRef, lastRequestIdRef, setIsSpeaking]);

  const speakText = useCallback(async (text: string, language: Lang = 'en'): Promise<void> => {
    if (!speechSynthesisSupported || !text?.trim()) return;

    if (isProcessingRef.current) {
      cancelSpeech();
      await new Promise(r => setTimeout(r, 80));
    }
    if (isSpeaking) {
      cancelSpeech();
      await new Promise(r => setTimeout(r, 100));
    }

    const requestId = Date.now().toString();
    lastRequestIdRef.current = requestId;
    isProcessingRef.current = true;

    return new Promise<void>((resolve, reject) => {
      try {
        if (lastRequestIdRef.current !== requestId) {
          isProcessingRef.current = false;
          resolve(); return;
        }

        let voices = window.speechSynthesis.getVoices();
        if (voices.length === 0) {
          const dummy = new SpeechSynthesisUtterance('');
          window.speechSynthesis.speak(dummy);
          window.speechSynthesis.cancel();
          voices = window.speechSynthesis.getVoices();
        }

        const utterance = new SpeechSynthesisUtterance(text);
        const voice = findBestVoiceForLanguage(language);
        if (voice) utterance.voice = voice;

        utterance.lang = language === 'es' ? 'es-ES' : 'en-US';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;

        let completed = false;
        const finish = () => {
          if (completed) return;
          completed = true;
          if (speechTimeoutRef.current) {
            clearTimeout(speechTimeoutRef.current);
            speechTimeoutRef.current = null;
          }
          isProcessingRef.current = false;
          currentUtteranceRef.current = null;
          setIsSpeaking(false);
          resolve();
        };

        utterance.onstart = () => {
          setIsSpeaking(true);
          // Shorter safety timeout => faster recovery if first utterance stalls
          const maxDuration = Math.max(10000, text.length * 100);
          speechTimeoutRef.current = setTimeout(() => {
            window.speechSynthesis.cancel();
            finish();
          }, maxDuration);
        };
        utterance.onend = finish;
        utterance.onerror = (e) => {
          finish();
          if (e.error !== 'interrupted' && e.error !== 'canceled') {
            reject(new Error(`Speech error: ${e.error}`));
          }
        };

        currentUtteranceRef.current = utterance;

        // Clear any stuck state first, then speak with tiny delay (mobile)
        window.speechSynthesis.cancel();
        setTimeout(() => {
          if (window.speechSynthesis.paused) window.speechSynthesis.resume();
          try {
            window.speechSynthesis.speak(utterance);
          } catch {
            // last resort
            setTimeout(() => window.speechSynthesis.speak(utterance), 120);
          }
        }, 40);
      } catch (err) {
        isProcessingRef.current = false;
        setIsSpeaking(false);
        reject(err);
      }
    });
  }, [speechSynthesisSupported, findBestVoiceForLanguage, isSpeaking, isProcessingRef, currentUtteranceRef, speechTimeoutRef, setIsSpeaking, lastRequestIdRef, cancelSpeech]);

  const stopSpeaking = useCallback(() => cancelSpeech(), [cancelSpeech]);

  return { speechSynthesisSupported, isSpeaking, speakText, stopSpeaking };
};

6c) components/chat/MobileSpeechButton.tsx (use the same voice picker)
// client/src/components/chat/MobileSpeechButton.tsx
import React, { useState } from 'react';
import { Volume2 } from 'lucide-react';
import { useVoiceSelection, Lang } from '@/hooks/speech/useVoiceSelection';

interface MobileSpeechButtonProps {
  text: string;
  language: Lang;
  className?: string;
}

const MobileSpeechButton: React.FC<MobileSpeechButtonProps> = ({ text, language, className = '' }) => {
  const [isSpeaking, setIsSpeaking] = useState(false);
  const { findBestVoiceForLanguage } = useVoiceSelection();

  const handleSpeak = () => {
    if (!text || isSpeaking || typeof window === 'undefined' || !window.speechSynthesis) return;

    try {
      setIsSpeaking(true);
      window.speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);
      const v = findBestVoiceForLanguage(language);
      if (v) u.voice = v;
      u.lang = language === 'es' ? 'es-ES' : 'en-US';
      u.rate = 0.88;
      u.pitch = 1.0;
      u.volume = 1.0;

      u.onend = () => setIsSpeaking(false);
      u.onerror = () => setIsSpeaking(false);

      setTimeout(() => window.speechSynthesis.speak(u), 80);
    } catch (e) {
      console.error('Mobile speech error:', e);
      setIsSpeaking(false);
    }
  };

  return (
    <button
      onClick={handleSpeak}
      className={`p-2 rounded-md transition-colors ${
        isSpeaking ? 'bg-blue-100 text-blue-600' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
      } ${className}`}
      aria-label="Play message"
    >
      <Volume2 className={`w-4 h-4 ${isSpeaking ? 'animate-pulse' : ''}`} />
    </button>
  );
};

export default MobileSpeechButton;

7) components/chat/ChatInput.tsx (unblock mobile nav + stop overlays)
// client/src/components/chat/ChatInput.tsx
// CHANGE: remove "relative z-30" wrapper or any high z-index around the input.
// Keep the component otherwise the same. Only the outermost div className changes.

return (
  <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
    {/* ...rest of your component unchanged... */}
  </div>
);


If you still have a navbar/footer with fixed + z-40/50, ensure those elements don’t overlay the page (or set pointer-events-none on purely decorative layers).

8) Chat: consistent language & crisis triage
8a) utils/language.ts (simple language detector)
// client/src/utils/language.ts
export type Lang = 'en' | 'es';

// Very lightweight heuristic; replace with a proper lib if desired.
export const detectLanguage = (text: string): Lang => {
  const s = text.toLowerCase();
  const esHits = ['hola', 'gracias', 'estoy', 'estás', 'necesito', 'ayuda', 'ansiedad', 'ánimo', 'mañana', 'porque', 'qué', 'cómo', 'sí'];
  const count = esHits.reduce((acc, w) => (s.includes(w) ? acc + 1 : acc), 0);
  return count >= 2 ? 'es' : 'en';
};

8b) utils/escalation.ts (reduce false positives)
// client/src/utils/escalation.ts
export interface AnalysisLike {
  anxietyLevel?: number;
  sentiment?: 'positive' | 'neutral' | 'negative' | 'crisis';
  escalationDetected?: boolean;
}

const RISK_KEYWORDS = [
  'suicide', 'kill myself', 'end my life', 'want to die', 'self harm', 'overdose',
  'hurt myself', 'jump off', 'no reason to live'
];

export const shouldEscalate = (
  lastUserText: string,
  analysis?: AnalysisLike,
  recentWindowHighLevelCount = 0
): boolean => {
  const text = (lastUserText || '').toLowerCase().trim();

  // Hard gate: explicit risk language
  const explicit = RISK_KEYWORDS.some(k => text.includes(k));
  if (explicit) return true;

  // Otherwise require BOTH: high objective level + negative context,
  // and not just "okay", "I don't want to talk" etc.
  const lowContent = /^ok(ay)?$|^k$|^no$|^nothing$|^fine$|^whatever$/.test(text);
  if (lowContent) return false;

  const a = analysis || {};
  const high = (a.anxietyLevel ?? 0) >= 9 || a.sentiment === 'crisis' || a.escalationDetected === true;

  // Also require recent accumulation (rate limiting)
  const accumulated = recentWindowHighLevelCount >= 2;

  return high && accumulated; // must be both high and repeated
};

8c) ChatContainer.tsx (language + escalation gates + faster first voice)
// client/src/containers/ChatContainer.tsx
import React from 'react';
import { useLocation } from 'react-router-dom';
import ChatHeader from '@/components/ChatHeader';
import AvatarSection from '@/components/chat/AvatarSection';
import ChatSection from '@/components/chat/ChatSection';
import { GoalSuggestionModal } from '@/components/goals/GoalSuggestionModal';
import { CrisisResourcesModal } from '@/components/CrisisResourcesModal';
import { useAnxietyAnalysis } from '@/hooks/useAnxietyAnalysis';
import { useChat } from '@/hooks/useChat';
import { useAvatarEmotions } from '@/hooks/useAvatarEmotions';
import { useChatInteractions } from '@/hooks/useChatInteractions';
import { useGoalSuggestions } from '@/hooks/useGoalSuggestions';
import { detectLanguage } from '@/utils/language';
import { shouldEscalate } from '@/utils/escalation';

interface ChatContainerProps {
  sessionId?: string | null;
}

const ChatContainer = ({ sessionId }: ChatContainerProps) => {
  const location = useLocation();
  const initialMessage = location.state?.initialMessage;

  const {
    messages,
    inputText,
    setInputText,
    isTyping,
    isAnalyzing,
    currentLanguage,
    aiCompanion,
    scrollRef,
    handleSendMessage,
    editMessage
  } = useChat(sessionId);

  const { anxietyAnalyses, currentAnxietyAnalysis } = useAnxietyAnalysis();

  const {
    showSuggestionModal,
    suggestedGoals,
    triggerGoalSuggestion,
    closeSuggestionModal
  } = useGoalSuggestions();

  const {
    isAnimating,
    currentEmotion,
    latestAnalysis,
    allAnalyses
  } = useAvatarEmotions(
    aiCompanion,
    messages,
    isTyping,
    anxietyAnalyses,
    currentAnxietyAnalysis
  );

  const {
    isListening,
    speechSupported,
    speechSynthesisSupported,
    languageContext,
    isSpeaking,
    handleToggleListening,
    handleKeyPress,
    handleAutoStartListening,
    handleSpeakText,
    stopSpeaking
  } = useChatInteractions(currentLanguage, setInputText, handleSendMessage);

  const [useReadyPlayerMe, setUseReadyPlayerMe] = React.useState(true);
  const [avatarIsSpeaking, setAvatarIsSpeaking] = React.useState(false);
  const [lastSpokenMessageId, setLastSpokenMessageId] = React.useState<string | null>(null);
  const [showCrisisModal, setShowCrisisModal] = React.useState(false);
  const [autoSpeak, setAutoSpeak] = React.useState(() => {
    const saved = localStorage.getItem('autoSpeak');
    return saved !== null ? saved === 'true' : true;
  });

  // Prime language from the very first user input (or initialMessage)
  React.useEffect(() => {
    const src = initialMessage?.trim() || messages[0]?.text || '';
    if (src) {
      const lang = detectLanguage(src);
      languageContext.setLanguage(lang);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Force-reset voice state on mount for mobile stability
  React.useEffect(() => {
    setAvatarIsSpeaking(false);
    setLastSpokenMessageId(null);
    stopSpeaking();
  }, [stopSpeaking]);

  // Initial message auto-speak (faster)
  React.useEffect(() => {
    if (!autoSpeak) return;
    const last = messages[messages.length - 1];
    if (!last) return;
    if (last.sender !== 'ai') return;
    if (isTyping || avatarIsSpeaking || last.id === lastSpokenMessageId) return;
    const lang = detectLanguage(last.text || '');
    languageContext.setLanguage(lang);

    (async () => {
      setLastSpokenMessageId(last.id);
      setAvatarIsSpeaking(true);
      try {
        await handleSpeakText(last.text);
      } catch (e) {
        console.warn('Auto speak failed:', e);
      } finally {
        setAvatarIsSpeaking(false);
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages, isTyping, handleSpeakText, avatarIsSpeaking, lastSpokenMessageId, autoSpeak]);

  // Crisis escalation gate: reduce false positives
  const recentHighAnxietyCount = React.useMemo(() => {
    const last5 = (allAnalyses ?? []).slice(0, 5);
    return last5.filter(a => (a.anxietyLevel ?? a.anxiety_level ?? 0) >= 8).length;
  }, [allAnalyses]);

  const handleMaybeShowCrisis = React.useCallback((text: string) => {
    const escalate = shouldEscalate(text, latestAnalysis, recentHighAnxietyCount);
    if (escalate) setShowCrisisModal(true);
  }, [latestAnalysis, recentHighAnxietyCount]);

  // Suggest goals only when helpful (unchanged, just ensure language stays in sync)
  React.useEffect(() => {
    const lastUser = (messages ?? []).slice().reverse().find(m => m.sender === 'user');
    if (!lastUser || !currentAnxietyAnalysis || showSuggestionModal || isTyping) return;

    // keep language aligned to user’s last message content
    languageContext.setLanguage(detectLanguage(lastUser.text || ''));

    setTimeout(() => {
      triggerGoalSuggestion(lastUser.text, currentAnxietyAnalysis);
      // Also consider crisis gate here
      handleMaybeShowCrisis(lastUser.text || '');
    }, 1200);
  }, [messages, currentAnxietyAnalysis, triggerGoalSuggestion, showSuggestionModal, isTyping, languageContext, handleMaybeShowCrisis]);

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col pb-20 md:pb-0">
      <ChatHeader
        speechSynthesisSupported={speechSynthesisSupported}
        speechSupported={speechSupported}
        aiCompanion={aiCompanion}
        currentLanguage={languageContext.currentLanguage}
      />

      <div className="flex-1 max-w-6xl mx-auto w-full p-4 flex flex-col lg:flex-row gap-4 mb-safe">
        <AvatarSection
          aiCompanion={aiCompanion}
          isAnimating={avatarIsSpeaking || isAnimating}
          isTyping={isTyping}
          currentEmotion={currentEmotion}
          useReadyPlayerMe={useReadyPlayerMe}
          setUseReadyPlayerMe={setUseReadyPlayerMe}
          onStoppedSpeaking={() => { setAvatarIsSpeaking(false); stopSpeaking(); }}
        />

        <ChatSection
          messages={messages}
          inputText={inputText}
          setInputText={setInputText}
          isTyping={isTyping}
          isAnalyzing={isAnalyzing}
          isListening={isListening}
          speechSupported={speechSupported}
          aiCompanion={aiCompanion}
          currentLanguage={languageContext.currentLanguage}
          scrollRef={scrollRef}
          latestAnalysis={latestAnalysis}
          allAnalyses={allAnalyses}
          onToggleListening={handleToggleListening}
          onSendMessage={() => {
            // Each send: set language from input to keep voice aligned
            languageContext.setLanguage(detectLanguage(inputText));
            handleSendMessage();
          }}
          onKeyPress={handleKeyPress}
          onEditMessage={editMessage}
          onStopSpeaking={stopSpeaking}
          isSpeaking={isSpeaking}
          onShowCrisisResources={() => setShowCrisisModal(true)}
          autoSpeak={autoSpeak}
          onToggleAutoSpeak={() => {
            const newValue = !autoSpeak;
            setAutoSpeak(newValue);
            localStorage.setItem('autoSpeak', String(newValue));
          }}
        />
      </div>

      <GoalSuggestionModal
        isOpen={showSuggestionModal}
        onClose={closeSuggestionModal}
        suggestedGoals={suggestedGoals}
        aiCompanion={aiCompanion}
      />

      <CrisisResourcesModal
        isOpen={showCrisisModal}
        onClose={() => setShowCrisisModal(false)}
      />
    </div>
  );
};

export default ChatContainer;

9) Optional: Dual-model router (Claude 4.1 + GPT-5 Thinking)

If you want the hybrid setup now, add these two:

9a) server/aiRouter.ts
// server/aiRouter.ts
import type { Request } from 'express';

type Model = 'claude-4.1-opus' | 'gpt-5-thinking';

export const pickModel = (req: Request): Model => {
  // Example routing:
  // - Use GPT-5 for short, empathic clinical replies
  // - Use Claude for longer reasoning / summaries
  const task = (req.body?.task || '').toLowerCase();
  if (task.includes('summar') || task.includes('plan') || task.includes('analysis')) {
    return 'claude-4.1-opus';
  }
  return 'gpt-5-thinking';
};

export const systemPrompt = `
You are a licensed behavioral health assistant.
Respond briefly, clinically accurately, and empathetically.
Default to 2–4 concise sentences. Avoid hedging. Use plain language.
If the user is in Spanish, respond in Spanish with a neutral Latin American tone.
Do not recommend emergency services unless clear high-risk signals are present.
`;

9b) server/routes.chat.ts
// server/routes.chat.ts
import express from 'express';
import { pickModel, systemPrompt } from './aiRouter';

const chat = express.Router();

chat.post('/api/chat', async (req, res) => {
  try {
    const model = pickModel(req);
    const { messages } = req.body; // [{role:'user'|'assistant'|'system', content:string}...]

    const finalMessages = [
      { role: 'system', content: systemPrompt },
      ...(messages ?? [])
    ];

    // Pseudocode: call your two providers
    let out: string;
    if (model === 'gpt-5-thinking') {
      out = await callOpenAI({ model: 'gpt-5-thinking', messages: finalMessages });
    } else {
      out = await callAnthropic({ model: 'claude-4.1-opus', messages: finalMessages });
    }

    res.json({ model, reply: out });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Chat failed' });
  }
});

export default chat;

Final notes

Intervention Summaries now show because the server guarantees a single summaries array with normalized fields, and the component is defensive.

Mobile taps work once high z-index overlays are removed (we removed z-30 in ChatInput wrapper). If you still see it, search any fixed overlays with z-40/50 and set pointer-events-none on decorative layers.

TTS is consistent across web & mobile via a shared voice picker + faster first-utterance (preload + cancel/resume + shorter safety timeout).

Language switching is stabilized by detecting language on input/AI output and updating the voice before speaking.

Crisis prompts are gated by explicit keywords or repeated extreme scores, so “okay / don’t want to talk” won’t escalate.

Dual-model router is optional; drop in if/when you want the blend.

If you paste these files/patches in as-is, you’ll cover all issues you raised.