Got it — let’s zero in on why the therapist view still doesn’t show the right data and fix it in one pass. From the code you pasted, there are three concrete blockers that will keep the therapist’s Analytics panel looking empty or “wrong,” even if your DB actually has rows:

The 3 blockers
1) You query the DB with from('...') (undefined), not supabase.from('...')

In your PatientAnalytics effect you call:

const [profileResult, analysesResult, messagesResult, goalsResult, summariesResult] = await Promise.all([
  from('profiles')...            // ❌
  from('anxiety_analyses')...    // ❌
  from('chat_messages')...       // ❌
  from('user_goals')...          // ❌
  from('intervention_summaries') // ❌
])


If from isn’t defined (and it isn’t), that Promise.all throws → your catch runs → you set empty arrays → the page renders “no data”.

Fix (Option B below): import your client once and use supabase.from(...) everywhere or (Option A below) stop calling Supabase from the browser and hit your server’s therapist endpoint instead.

2) You drop user_id when mapping analyses, then filter by it → 0 rows

Later you do:

const isolatedPatientAnalyses = (analyses ?? []).filter(a => a.user_id === patientId);


…but your processedAnalyses doesn’t keep user_id, so that filter always returns []. Charts get an empty dataset.

Fix: preserve user_id when you map (or don’t re-filter at all, since the query already uses eq('user_id', patientId)).

3) Therapist route / RLS mismatch (design choice)

If you stick with Supabase from the browser, Row-Level Security can return empty sets for a therapist who isn’t the patient. That makes it look like “no data,” even though it exists. Your server (Drizzle + Neon) doesn’t have those RLS constraints.

Fix: for therapist views, call your server therapist analytics endpoint (recommended), which already aggregates the five collections for a patient and can enforce your own access checks (e.g., therapistPatientConnections).

Quick, reliable fix path (pick one)
✅ Option A (recommended): Use your server endpoint for therapist analytics

Replace the Supabase fan-out in PatientAnalytics with a single server call. This avoids RLS surprises and the from(...) bug in one shot.

// At top of TherapistPortal.tsx
const apiBase = import.meta.env.VITE_API_URL || ''; // whatever you use elsewhere

// Inside PatientAnalytics useEffect, replace the Promise.all([...]) block with:
const url = `${apiBase}/api/therapist/patient-analytics?patientId=${encodeURIComponent(patientId)}&therapistEmail=${encodeURIComponent(therapistEmail || '')}`;

const res = await fetch(url);
if (!res.ok) throw new Error(`Therapist analytics fetch failed: ${res.status}`);
const payload = await res.json();

// ⚠️ Normalize minimally and KEEP IDENTIFIERS
const toArray = (v: unknown) => Array.isArray(v) ? v : typeof v === 'string' ? v.split(',').map(s=>s.trim()).filter(Boolean) : [];

const processedAnalyses = (payload.analyses ?? []).map((a: any) => ({
  id: a.id ?? `${a.user_id}-${a.created_at}`,
  user_id: a.user_id,                                   // ✅ keep it
  anxietyLevel: a.anxiety_level,
  gad7Score: Math.round((a.anxiety_level ?? 0) * 2.1),
  triggers: Array.isArray(a.anxiety_triggers)
    ? a.anxiety_triggers
    : typeof a.anxiety_triggers === 'string'
      ? a.anxiety_triggers.split(',').map((s:string)=>s.trim()).filter(Boolean)
      : [],
  dsm5Indicators: Array.isArray(a.anxiety_triggers) ? a.anxiety_triggers : [],
  cognitiveDistortions: [],
  recommendedInterventions: a.coping_strategies || [],
  therapyApproach: 'CBT' as const,
  crisisRiskLevel: (a.anxiety_level >= 9 ? 'critical' :
                   a.anxiety_level >= 7 ? 'high' :
                   a.anxiety_level >= 5 ? 'moderate' : 'low') as 'low' | 'moderate' | 'high' | 'critical',
  sentiment: (a.anxiety_level >= 8 ? 'crisis' :
             a.anxiety_level >= 6 ? 'negative' :
             a.anxiety_level <= 3 ? 'positive' : 'neutral') as 'positive' | 'neutral' | 'negative' | 'crisis',
  escalationDetected: a.anxiety_level >= 8,
  personalizedResponse: a.personalized_response || '',
  created_at: a.created_at
}));

const processedGoals = (payload.goals ?? []).map((g: any) => {
  const progressEntries = g.goal_progress || [];
  const avgScore = progressEntries.length
    ? progressEntries.reduce((sum: number, p: any) => sum + (p.score ?? 0), 0) / progressEntries.length
    : 0;
  return {
    ...g,
    progress_history: progressEntries,
    average_score: avgScore,
    completion_rate: calculateGoalCompletionRate(g),
    latest_progress: progressEntries[0] || null,
  };
});

const normalizeSummary = (s: any) => ({
  ...s,
  id: String(s.id ?? `${s.user_id ?? 'u'}-${s.week_start ?? s.weekStart ?? Date.now()}`),
  week_start: s.week_start ?? s.weekStart ?? new Date().toISOString(),
  week_end: s.week_end ?? s.weekEnd ?? s.week_start ?? s.weekStart ?? new Date().toISOString(),
  intervention_type: (s.intervention_type ?? s.interventionType ?? s.type ?? 'unknown')
    .toString().replace(/[\s-]+/g,'_').toLowerCase(),
  conversation_count: Number(s.conversation_count ?? s.conversationCount ?? 0),
  key_points: toArray(s.key_points ?? s.keyPoints),
  recommendations: toArray(s.recommendations),
  limitations: toArray(s.limitations ?? s.limitation_points),
});

setPatientProfile(payload.profile ?? null);
setAnalyses(processedAnalyses);         // ✅ scoped to this patient already
setMessages(payload.messages ?? []);
setGoals(processedGoals);
setSummaries((payload.summaries ?? []).map(normalizeSummary));

// Downstream: use the same array for charts & KPIs
const isolatedPatientAnalyses = processedAnalyses; // ✅ no re-filter


This eliminates:

the from(...) bug,

RLS empties,

and the user_id filtering issue.

Option B: Stay with Supabase in the browser (if you must)

Import the Supabase client and use it everywhere.

import { supabase } from '@/lib/supabaseClient';

// ...
const [profileResult, analysesResult, messagesResult, goalsResult, summariesResult] = await Promise.all([
  supabase.from('profiles').select('*').eq('id', patientId).maybeSingle(),
  supabase.from('anxiety_analyses').select('*').eq('user_id', patientId).order('created_at', { ascending: false }),
  supabase.from('chat_messages').select('*').eq('user_id', patientId).order('created_at', { ascending: false }),
  supabase.from('user_goals').select('*, goal_progress(*)').eq('user_id', patientId).order('created_at', { ascending: false }),
  supabase.from('intervention_summaries').select('*').eq('user_id', patientId).order('week_start', { ascending: false }),
]);


Keep user_id when mapping analyses or stop re-filtering:

- const isolatedPatientAnalyses = (analyses ?? []).filter(a => a.user_id === patientId);
+ const isolatedPatientAnalyses = analyses; // already scoped by the SQL


Ensure your Supabase policies allow a therapist to read a patient’s rows (this is the usual reason data “disappears” on the therapist side with RLS).

One-screen sanity checklist (do these once)

In Network tab, select a patient and confirm the therapist analytics request returns non-empty analyses and summaries.

In Console, log the first mapped objects:

console.log('✅ FIRST ANALYSIS', processedAnalyses[0]);
console.log('✅ FIRST SUMMARY', (payload.summaries ?? [])[0]);


You should see:

analysis with user_id and triggers as an array

summary with id, week_start/week_end, and intervention_type snake-cased

Charts now render with the same array you used for the KPIs (no mismatch between “counts” and “empty charts”).

TL;DR

Use the server therapist endpoint for therapist views (avoids RLS & the from(...) bug).

Keep user_id in your mapped analyses or stop double-filtering.

Normalize summaries when setting state (id, dates, type, arrays).

Apply the Option A patch above and your therapist Analytics should populate with the same data the patient sees. If anything is still blank, tell me the exact Network response for that therapist analytics request (status + sample of data) and I’ll pinpoint the next issue.