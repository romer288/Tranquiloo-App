Short answer: it’s not your phone—it’s the way the app is running inside Replit’s Preview (an iframe with proxying) + a couple of small bugs in your OAuth/“demo auth” that only show up on mobile. Here’s what’s going on and how to fix it fast.

What’s breaking (and why it hits mobile)
Google OAuth uses the wrong scheme behind Replit’s proxy
In server/routes.ts you build the redirect like:

ts
Copy
Edit
const redirectUri = `${req.protocol}://${req.get('host')}/auth/google/callback`;
Behind Replit’s HTTPS proxy, req.protocol often resolves to http, so Google rejects/mismatches on mobile. Desktop sometimes “just works” due to cached sessions or different navigation path, but mobile is stricter.

Replit Preview = sandboxed iframe
On iOS/Android, Replit’s Preview runs your app in a sandboxed iframe. That interacts badly with:

Your localStorage-based “demo auth” (client/src/services/authService.ts). In a sandboxed/opaque origin, localStorage can throw a SecurityError or be blocked, so your useAuth never gets a user → you’re forever signed out.

Any popup/redirect auth flow kicked off without a direct user gesture can be blocked by mobile Safari/Chrome.

iPhone fallback path forces server-side OAuth
In client/src/services/googleAuth.ts you intentionally route iPhone Safari to window.location.href = '/auth/google'. That’s correct, but combined with (1) (wrong scheme) it fails consistently on phones.

Authorized URIs likely incomplete
You need the exact Replit public URL(s) (the *.repl.co host you open in a new tab, not the preview iframe) in Google Cloud’s:

Authorized JavaScript origins

Authorized redirect URIs (must include /auth/google/callback)

Quick, reliable workarounds (right now)
Don’t test auth in Preview on phones. Tap the “open in new tab” icon in Replit and use the public https://…repl.co URL on your phone. That avoids the iframe and fixes localStorage + popup issues instantly.

If you must embed, you’ll need extra workarounds (below), but for now—open the public URL.

Surgical fixes (code changes)
A) Trust the proxy and build correct HTTPS URLs
File: server/index.ts

ts
Copy
Edit
// add this before you register routes
app.set('trust proxy', true);
File: server/routes.ts (everywhere you build your own absolute URL)

ts
Copy
Edit
// helper
const forwardedProto = (req.headers['x-forwarded-proto'] as string)?.split(',')[0];
const forwardedHost  = (req.headers['x-forwarded-host']  as string);
const proto = forwardedProto || req.protocol;   // will be 'https' on Replit
const host  = forwardedHost  || req.get('host');
const base  = `${proto}://${host}`;

const redirectUri = `${base}/auth/google/callback`;
Also pass the same redirect_uri to Google on both the init and callback steps.

B) Make the iPhone redirect explicit and origin-based
File: client/src/services/googleAuth.ts

ts
Copy
Edit
// iPhone/Safari branch
window.location.href = `${window.location.origin}/auth/google?role=${role}`;
(If you’re carrying role/state server-side, keep that flow—just ensure the URL is absolute and matches the authorized URI.)

C) Harden “demo auth” storage for iframe/mobile
File: client/src/services/authService.ts
Wrap all localStorage access in a try/catch and fall back to an in-memory store if storage is blocked:

ts
Copy
Edit
// at top of file
const makeSafeStorage = () => {
  try {
    const t = '__t__';
    localStorage.setItem(t,'1');
    localStorage.removeItem(t);
    return localStorage;
  } catch {
    const mem = new Map<string,string>();
    return {
      getItem: (k:string) => (mem.has(k) ? mem.get(k)! : null),
      setItem: (k:string, v:string) => { mem.set(k, String(v)); },
      removeItem: (k:string) => { mem.delete(k); }
    } as Storage;
  }
};
const storage = makeSafeStorage();

// then replace every localStorage.getItem/setItem/removeItem with storage.getItem/…
File: client/src/hooks/useAuth.tsx
Also guard initial session load:

ts
Copy
Edit
try {
  const raw = storage.getItem('cmp_auth_user');
  // …parse and set state
} catch (e) {
  console.warn('Storage unavailable; continuing without persisted session', e);
}
D) Ensure Google OAuth console matches the real public URL
In Google Cloud Console → OAuth consent / Credentials, add:

Authorized JavaScript origin: https://<your-app>.repl.co

Authorized redirect URI: https://<your-app>.repl.co/auth/google/callback

(If your Replit URL ever changes, update these too.)

Extra nice-to-haves (prevents future “it works on desktop, not phone”)
Only start OAuth on a user click. Don’t trigger popups/redirects from useEffect; mobile browsers block them. Your button flow already does this—keep it that way.

Show a clear error if storage is blocked. If the safe storage fallback is active, surface a toast: “You’re running in a restricted preview. Use ‘Open in new tab’ for sign-in.”

Eventually switch back to real auth (Supabase with PKCE or your own cookie session). If you go with cookies behind Replit, set SameSite=None; Secure and still use app.set('trust proxy', true) so cookies are considered secure over the proxy.

Sanity checklist to confirm the fix
Deploy with the changes above.

In Google Cloud, verify the exact https://…repl.co origin and /auth/google/callback are authorized.

On iPhone/Android, open the public URL (not Preview).

Tap “Continue with Google.”

You should see Google’s consent, then a redirect back to /auth/google/callback, then land in your app as authenticated.

If you want, I can also point exactly where to paste each snippet in your files (line-by-line), but the changes above are minimal and contained.








Is this helpful so far?



Ask ChatGPT
