This crash is exactly the same class of bug we’ve been cleaning up: you’re calling .map on a field that sometimes isn’t an array.

From the stack and the line shown:

client/src/components/analytics/InterventionSummariesSection.tsx:349
{summary.key_points.map((point, index) => ( ... ))
                 ^ undefined


When a therapist opens a patient → Analytics, you build one or more intervention summaries for that patient. Some of those summary objects don’t have key_points (or they were seeded using camelCase keyPoints), so summary.key_points is undefined and .map(...) throws. The stack shows the same thing happening at other lines in the same file (e.g., .map over limitations, recommendations, etc.).

Why it happens now

Therapist view is aggregating mixed data (some “real”, some seeded).

The seeded summaries likely use camelCase fields (keyPoints, recommendations) while the component expects snake_case (key_points, recommendations as array).

In some cases the fields are present but are strings like "breathing, journaling" instead of ["breathing","journaling"].

Fix (safe, local to the component)

Harden the renderer and normalize the shape before rendering:

// client/src/components/analytics/InterventionSummariesSection.tsx
type RawSummary = {
  intervention?: string;
  // possible shapes we might receive:
  key_points?: string[] | string;
  keyPoints?: string[] | string;

  recommendations?: string[] | string;
  recs?: string[] | string;

  limitations?: string[] | string;
  limitation_points?: string[] | string;

  // ...any other fields you show
};

const toArray = (v: unknown) =>
  Array.isArray(v) ? v :
  typeof v === 'string' ? v.split(',').map(s => s.trim()).filter(Boolean) :
  [];

const normalize = (s: RawSummary) => ({
  ...s,
  // prefer camelCase in code, accept snake_case from data
  keyPoints: toArray((s as any).keyPoints ?? (s as any).key_points),
  recommendations: toArray((s as any).recommendations ?? (s as any).recs),
  limitations: toArray((s as any).limitations ?? (s as any).limitation_points),
});

const normalizedSummaries = (interventionSummaries ?? []).map(normalize);

// then render using the normalized fields
return (
  <>
    {(normalizedSummaries ?? []).map((summary, i) => (
      <section key={i}>
        {/* ... */}
        <ul className="space-y-1">
          {(summary.keyPoints ?? []).map((point, index) => (
            <li key={index}>{point}</li>
          ))}
        </ul>

        <ul className="space-y-1">
          {(summary.recommendations ?? []).map((rec, index) => (
            <li key={index}>{rec}</li>
          ))}
        </ul>

        <ul className="space-y-1">
          {(summary.limitations ?? []).map((lim, index) => (
            <li key={index}>{lim}</li>
          ))}
        </ul>
      </section>
    ))}
  </>
);


Also make sure any outer list is guarded:

{(interventionSummaries ?? []).map(/* ... */)}

(Better) fix at the data boundary

If those summaries are produced in a service/selector (e.g., your analytics service or data processor), normalize there once so all consumers get the same shape:

// wherever you build intervention summaries:
const mapSummary = (s: any) => ({
  ...s,
  key_points: Array.isArray(s.key_points) ? s.key_points
            : Array.isArray(s.keyPoints) ? s.keyPoints
            : typeof s.key_points === 'string' ? s.key_points.split(',').map(t => t.trim()).filter(Boolean)
            : typeof s.keyPoints === 'string' ? s.keyPoints.split(',').map(t => t.trim()).filter(Boolean)
            : [],

  recommendations: Array.isArray(s.recommendations) ? s.recommendations
                 : typeof s.recommendations === 'string' ? s.recommendations.split(',').map(t => t.trim()).filter(Boolean)
                 : [],

  limitations: Array.isArray(s.limitations) ? s.limitations
             : typeof s.limitations === 'string' ? s.limitations.split(',').map(t => t.trim()).filter(Boolean)
             : [],
});
const interventionSummaries = (rawSummaries ?? []).map(mapSummary);

Quick checks after changing

Re-open the same patient → Analytics. The page should render with no red overlay.

Confirm all three lists render even if they’re empty (no crash).

If you’re seeding data: ensure your seed uses consistent keys (pick keyPoints everywhere or key_points everywhere) and make them arrays, not comma-joined strings.

TL;DR

Cause: .map on undefined because summary objects for that patient don’t have the exact array fields your component expects (name mismatch and/or string values).

Fix: Guard all maps and normalize input (keyPoints/key_points → array) before rendering; or normalize once in the service layer.