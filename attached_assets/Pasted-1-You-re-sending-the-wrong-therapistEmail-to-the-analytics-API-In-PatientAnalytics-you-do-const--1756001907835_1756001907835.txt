1) You’re sending the wrong therapistEmail to the analytics API

In PatientAnalytics you do:

const { user } = useAuth();
const therapistEmail = user?.email; // ← this is usually undefined here


But your “login” in TherapistPortal is a local state gate (not real auth), so useAuth() often has no user. That means your request goes to:

/api/therapist/patient-analytics?patientId=...&therapistEmail=


…and your server route requires both values and returns 400.

Fix (minimal)

Pass the email you collected in the parent down as a prop and stop reading useAuth() inside PatientAnalytics.

TherapistPortal.tsx

{/* Main Content Area */}
<div className="flex-1 p-6">
  {selectedPatientId ? (
    <PatientAnalytics
      patientId={selectedPatientId}
      therapistEmail={therapistEmail}  // ✅ pass it down
    />
  ) : (/* ... */)}
</div>


Change the signature and usage in PatientAnalytics

// before: const PatientAnalytics: React.FC<{ patientId: string }>
const PatientAnalytics: React.FC<{ patientId: string; therapistEmail: string }> = ({ patientId, therapistEmail }) => {
  // remove: const { user } = useAuth(); const therapistEmail = user?.email;
  // ...
  const url = `/api/therapist/patient-analytics?patientId=${encodeURIComponent(patientId)}&therapistEmail=${encodeURIComponent(therapistEmail)}`;
  // ...
}

2) The patient search call doesn’t match your server route

Your UI calls:

fetch(`/api/therapist/search-patient?email=...&code=...`) // GET with query params


Your server route is:

app.post('/api/therapist/search-patient', async (req, res) => {
  const { email, patientCode } = req.body; // expects POST body AND BOTH fields
  // returns a single object, not an array
});


So the UI:

Uses GET (server expects POST).

Sends only email OR code (server requires both to match).

Expects an array of profiles (server returns a single object).

This is why your “Results (0)” keeps showing and you never even reach the analytics screen reliably.

Pick one of these fixes

Option A — change the UI to POST & expect one object

const res = await fetch('/api/therapist/search-patient', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: searchEmail.trim(), patientCode: searchCode.trim() })
});
const found = await res.json(); // single object
const formattedPatients = found ? [{
  id: found.id,
  user_id: found.id,
  therapist_name: therapistEmail,
  contact_value: therapistEmail,
  created_at: found.created_at,
  patient_profile: {
    first_name: found.firstName,  // server uses camelCase
    last_name:  found.lastName,
    email:      found.email
  }
}] : [];
setPatients(formattedPatients);


Option B — change the server to support GET + either email or code + return array
(If you prefer the new UI shape.)

3) Field-name casing in analytics payload isn’t normalized

Your server/storage likely returns camelCase (createdAt, anxietyLevel, etc.) in some places and snake_case in others. In processedAnalyses you only read snake_case:

anxietyLevel: a.anxiety_level,
triggers: a.anxiety_triggers,
created_at: a.created_at,
user_id: a.user_id,


If storage returns anxietyLevel, anxietyTriggers, createdAt, userId, these become undefined, so charts compute zeros and appear blank.

Fix the mapper (one line per field, accept both cases)
const processedAnalyses = (payload.analyses ?? []).map((a: any) => {
  const anxietyLevel = a.anxiety_level ?? a.anxietyLevel ?? 0;
  const triggersRaw  = a.anxiety_triggers ?? a.triggers ?? [];
  const createdAt    = a.created_at ?? a.createdAt ?? new Date().toISOString();
  const userId       = a.user_id ?? a.userId ?? patientId;

  const triggers = Array.isArray(triggersRaw)
    ? triggersRaw
    : typeof triggersRaw === 'string'
      ? triggersRaw.split(',').map((s: string) => s.trim()).filter(Boolean)
      : [];

  return {
    id: a.id ?? `${userId}-${createdAt}`,
    user_id: userId,                         // ✅ keep identifier
    anxietyLevel,
    gad7Score: Math.round((anxietyLevel || 0) * 2.1),
    triggers,
    dsm5Indicators: triggers,
    cognitiveDistortions: [],
    recommendedInterventions: a.coping_strategies ?? a.copingStrategies ?? [],
    therapyApproach: 'CBT' as const,
    crisisRiskLevel: anxietyLevel >= 9 ? 'critical' : anxietyLevel >= 7 ? 'high' : anxietyLevel >= 5 ? 'moderate' : 'low',
    sentiment: anxietyLevel >= 8 ? 'crisis' : anxietyLevel >= 6 ? 'negative' : anxietyLevel <= 3 ? 'positive' : 'neutral',
    escalationDetected: anxietyLevel >= 8,
    personalizedResponse: a.personalized_response ?? a.personalizedResponse ?? '',
    created_at: createdAt,
  };
});


Do the same casing-bridges for goals (goal_progress vs goalProgress) and summaries (week_start/weekStart, etc.). You already normalized summaries nicely—keep that pattern.

Quick checklist to get the therapist analytics showing real data

Propagate therapist email correctly

Pass therapistEmail from TherapistPortal state to PatientAnalytics via prop.

Use that prop in the analytics API URL.

Make search and server agree

Either: change UI to POST /api/therapist/search-patient with { email, patientCode } and expect one object → wrap it into an array for your list.

Or: change the server to accept your new GET shape and return an array.

Normalize payload fields

Map snake_case and camelCase for all analytics inputs (analyses, goals, summaries).

Ensure user_id is present in processedAnalyses (some charts/logs rely on it).

Remove dead re-filtering

You already scope on the server; keep isolatedPatientAnalyses = analyses; as you did, but only if you’re sure the API returns a single patient’s data. Otherwise, keep the filter(a.user_id === patientId).

Make those four small changes and the therapist analytics should populate with the same data you see on the patient side.