You’ve fixed the renderer, but the therapist view still shows “no data” because the data you pass into the charts/sections is empty. That’s happening for two concrete reasons in the code you pasted:

1) You drop user_id when you transform analyses

You later filter by user_id, but your mapped objects don’t contain it, so the filter returns 0 items.

Where it breaks

// PatientAnalytics → fetchPatientData()
const processedAnalyses = (analysesResult.data || []).map(analysis => ({
  // ❌ you never keep analysis.user_id
  anxietyLevel: analysis.anxiety_level,
  ...
  created_at: analysis.created_at
}));

// later:
const isolatedPatientAnalyses = (analyses ?? []).filter(a => a.user_id === patientId);
// -> always [] because a.user_id is undefined


Fix (keep the identifiers)

const processedAnalyses = (analysesResult.data || []).map(analysis => ({
+ id: analysis.id ?? `${analysis.user_id}-${analysis.created_at}`,
+ user_id: analysis.user_id,
  anxietyLevel: analysis.anxiety_level,
  gad7Score: Math.round(analysis.anxiety_level * 2.1),
  beckAnxietyCategories: ['General Anxiety'],
  dsm5Indicators: analysis.anxiety_triggers || [],
  triggers: analysis.anxiety_triggers || [],
  cognitiveDistortions: [],
  recommendedInterventions: analysis.coping_strategies || [],
  therapyApproach: 'CBT' as const,
  crisisRiskLevel: (analysis.anxiety_level >= 9 ? 'critical' :
                   analysis.anxiety_level >= 7 ? 'high' :
                   analysis.anxiety_level >= 5 ? 'moderate' : 'low') as 'low' | 'moderate' | 'high' | 'critical',
  sentiment: (analysis.anxiety_level >= 8 ? 'crisis' :
             analysis.anxiety_level >= 6 ? 'negative' :
             analysis.anxiety_level <= 3 ? 'positive' : 'neutral') as 'positive' | 'neutral' | 'negative' | 'crisis',
  escalationDetected: analysis.anxiety_level >= 8,
  personalizedResponse: analysis.personalized_response || '',
  created_at: analysis.created_at
}));


Or simpler: don’t filter again—your SQL already does eq('user_id', patientId):

- const isolatedPatientAnalyses = (analyses ?? []).filter(a => a.user_id === patientId);
+ const isolatedPatientAnalyses = analyses; // already patient-scoped


Do one or the other (keeping user_id is useful anyway).

2) You’re calling Supabase with from(...) in one place and supabase.from(...) in another

In searchPatients() you use supabase.from, but in fetchPatientData() you call bare from('...'). If from isn’t globally defined you’ll hit the catch and end up with empty state every time.

Where

// searchPatients(): uses supabase.from ✅
let query = supabase.from('profiles').select(...)

// fetchPatientData(): uses from ❌
const [profileResult, analysesResult, ...] = await Promise.all([
  from('profiles').select('*').eq('id', patientId).maybeSingle(),
  from('anxiety_analyses').select('*').eq('user_id', patientId)...
  ...
]);


Fix

Import the client once at the top:

import { supabase } from '@/lib/supabaseClient';


Use it consistently:

- from('profiles')...
+ supabase.from('profiles')...

- from('anxiety_analyses')...
+ supabase.from('anxiety_analyses')...

- from('chat_messages')...
+ supabase.from('chat_messages')...

- from('user_goals')...
+ supabase.from('user_goals')...

- from('intervention_summaries')...
+ supabase.from('intervention_summaries')...

3) Summaries: ensure IDs & canonical fields exist (to avoid subtle render skips)

Your InterventionSummariesSection now normalizes fields, but the objects you put into summaries should also have id, week_start/week_end, intervention_type, conversation_count so list keys and badges render correctly.

You already normalize at the section level; add a light normalization when setting state to be safe:

const normalizeSummary = (s: any) => ({
  ...s,
+ id: String(s.id ?? `${s.user_id ?? 'u'}-${s.week_start ?? Date.now()}`),
+ intervention_type: (s.intervention_type ?? s.interventionType ?? 'unknown')
+   .toString().replace(/[\s-]+/g, '_').toLowerCase(),
+ conversation_count: Number(s.conversation_count ?? s.conversationCount ?? 0),
  week_start: s.week_start ?? s.weekStart ?? new Date().toISOString(),
+ week_end: s.week_end ?? s.weekEnd ?? s.week_start ?? s.weekStart ?? new Date().toISOString(),
  key_points: Array.isArray(s.key_points) ? s.key_points
          : Array.isArray(s.keyPoints) ? s.keyPoints
          : typeof s.key_points === 'string' ? s.key_points.split(',').map((t: string) => t.trim()).filter(Boolean)
          : typeof s.keyPoints === 'string' ? s.keyPoints.split(',').map((t: string) => t.trim()).filter(Boolean)
          : [],
  recommendations: Array.isArray(s.recommendations) ? s.recommendations
          : typeof s.recommendations === 'string' ? s.recommendations.split(',').map((t: string) => t.trim()).filter(Boolean)
          : [],
  limitations: Array.isArray(s.limitations) ? s.limitations
          : typeof s.limitations === 'string' ? s.limitations.split(',').map((t: string) => t.trim()).filter(Boolean)
          : [],
});

4) Use the same array for metrics and charts

You compute totalEntries, avgAnxiety, mostCommonTrigger from all analyses but pass isolatedPatientAnalyses to charts. After the fix in (1), either:

compute metrics from isolatedPatientAnalyses, or

set isolatedPatientAnalyses = analyses (recommended since the query is already filtered).

5) One more small guard to prevent silent blanks

If analysesResult.data returns rows with anxiety_triggers as string (e.g. "work, social"), split it when you map:

triggers: Array.isArray(analysis.anxiety_triggers)
            ? analysis.anxiety_triggers
          : typeof analysis.anxiety_triggers === 'string'
            ? analysis.anxiety_triggers.split(',').map(s => s.trim()).filter(Boolean)
            : [],
dsm5Indicators: same as triggers

After these changes

The fetch succeeds (supabase.from everywhere).

The objects passed to UI keep user_id (or you stop double-filtering).

Summaries have the minimal fields the section expects.

Charts/metrics operate on the same (non-empty) array.

If it still looks empty, log the first transformed item right before render:

console.log('FIRST ANALYSIS', analyses[0]);
console.log('FIRST SUMMARY', summaries[0]);


If those show up as expected, the UI will render. If they’re undefined, the fetch is still failing—check your Network tab for 401/403s or table names/row-level security.